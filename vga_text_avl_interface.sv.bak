/************************************************************************
Avalon-MM Interface VGA Text mode display

Register Map:
0x000-0x0257 : VRAM, 80x30 (2400 byte, 600 word) raster order (first column then row)
0x258        : control register

VRAM Format:
X->
[ 31  30-24][ 23  22-16][ 15  14-8 ][ 7    6-0 ]
[IV3][CODE3][IV2][CODE2][IV1][CODE1][IV0][CODE0]

IVn = Draw inverse glyph
CODEn = Glyph code from IBM codepage 437

Control Register Format:
[[31-25][24-21][20-17][16-13][ 12-9][ 8-5 ][ 4-1 ][   0    ] 
[[RSVD ][FGD_R][FGD_G][FGD_B][BKG_R][BKG_G][BKG_B][RESERVED]

VSYNC signal = bit which flips on every Vsync (time for new frame), used to synchronize software
BKG_R/G/B = Background color, flipped with foreground when IVn bit is set
FGD_R/G/B = Foreground color, flipped with background when Inv bit is set

************************************************************************/

`define NUM_PALETTES 8

module vga_text_avl_interface (

	input logic CLK_100,
	
	// Avalon Reset Input
	input logic RESET,
	
	// Avalon-MM Slave Signals
	input  logic AVL_READ,					// Avalon-MM Read
	input  logic AVL_WRITE,					// Avalon-MM Write
	input  logic AVL_CS,					// Avalon-MM Chip Select
	input  logic [3:0] AVL_BYTE_EN,			// Avalon-MM Byte Enable
	input  logic [11:0] AVL_ADDR,			// Avalon-MM Address
	input  logic [31:0] AVL_WRITEDATA,		// Avalon-MM Write Data
	output logic [31:0] AVL_READDATA,		// Avalon-MM Read Data
	
	// Exported Conduit (mapped to VGA port - make sure you export in Platform Designer)
	output logic [3:0]  red, green, blue,	// VGA color channels (mapped to output pins in top-level)
	output logic hs, vs						// VGA HS/VS
);

//put other local variables here
logic [10:0] ROM_ADDR;
logic [7:0] ROM_DATA;
logic [15:0] glyph_data;
logic [9:0] DrawX, DrawY;
logic [3:0] red_on, green_on, blue_on, red_off, green_off, blue_off;
logic CLK, pixel_clk, inv, pixel_on, blank;
logic [10:0] RAM_ADDR;
logic [1:0][15:0] RAM_DATA;
logic RAM_WRITE;
logic [31:0] RAM_WRITEDATA, RAM_READDATA;
logic [31:0] PALETTE [`NUM_PALETTES];
logic [3:0] FGD_IDX, BKG_IDX;
logic [11:0] FGD_COLOR, BKG_COLOR;

//Declare submodules..e.g. VGA controller, ROMS, etc
font_rom ROM(.addr(ROM_ADDR), .data(ROM_DATA));
vga_controller VGA(.Clk(CLK), .Reset(RESET), .hs(hs), .vs(vs), .pixel_clk(pixel_clk), .blank(blank), .DrawX(DrawX), .DrawY(DrawY));
   
// Read and write from AVL interface to register block, note that READ waitstate = 1, so this should be in always_ff
vram VRAM(.*, .AVL_WRITE(RAM_WRITE), .AVL_WRITEDATA(RAM_WRITEDATA), .AVL_READDATA(RAM_READDATA), .AVL_ADDR(AVL_ADDR[10:0]), .VGA_READDATA(RAM_DATA), .VGA_ADDR(RAM_ADDR));

// Divide 100 MHz input to necessary 50 MHz clock
always_ff @ (posedge CLK_100 or posedge RESET) begin
	if (RESET) 
		CLK <= 1'b0;
	else
		CLK <= ~CLK;
end

always_ff @ (posedge CLK) begin
	RAM_WRITE <= 1'b0;
	
	if(!AVL_ADDR[11]) begin
		if(AVL_WRITE) begin
			RAM_WRITE <= 1'b1;
			RAM_WRITEDATA <= AVL_WRITEDATA;
		end
		AVL_READDATA <= RAM_READDATA;
	end
	else begin
		if (AVL_WRITE) begin
			PALETTE[AVL_ADDR[2:0]] <= AVL_WRITEDATA;
		end
		AVL_READDATA <= PALETTE[AVL_ADDR[2:0]];
	end
	
	
	if(!blank) begin
		red <= 4'b0000;
		blue <= 4'b0000;
		green <= 4'b0000;
	end
	
	else if(pixel_on) begin
		red <= red_on;
		green <= green_on;
		blue <= blue_on;
	end
	
	else begin
		red <= red_off;
		green <= green_off;
		blue <= blue_off;
	end
end

//handle drawing (may either be combinational or sequential - or both).

always_comb begin

	RAM_ADDR = (DrawY[8:4] * 40) + DrawX[9:4];
	glyph_data = RAM_DATA[DrawX[3]];
	FGD_IDX = glyph_data[7:4];
	BKG_IDX = glyph_data[3:0];
	
	if (FGD_IDX[0]) begin
		FGD_COLOR = PALETTE[FGD_IDX[3:1]][24:13];
	end
	else begin
		FGD_COLOR = PALETTE[FGD_IDX[3:1]][12:1];
	end
		
	if (BKG_IDX[0]) begin
		BKG_COLOR = PALETTE[BKG_IDX[3:1]][24:13];
	end
	else begin
		BKG_COLOR = PALETTE[BKG_IDX[3:1]][12:1];
	end
	
	red_on = FGD_COLOR[11:8];
	green_on = FGD_COLOR[7:4];
	blue_on = FGD_COLOR[3:0];
	
	red_off = BKG_COLOR[11:8];
	green_off = BKG_COLOR[7:4];
	blue_off = BKG_COLOR[3:0];
	
	ROM_ADDR = {glyph_data[14:8],DrawY[3:0]};
	
	inv = glyph_data[15];
	
	pixel_on = ROM_DATA[~DrawX[2:0]];
	
	if(inv) begin
		pixel_on = !pixel_on;
	end
end

endmodule